# README

## ASTODO

以下のURLの技術を応用する．

<https://jpn.nec.com/techrep/journal/g19/n01/pdf/190120.pdf>

スタート
  ↓
(1) データ収集
  ├─ 熟練者の意思決定履歴（例：スケジュール、判断ログ）
  └─ 問題定義（最適化問題：どのようなスケジューリング問題か）
        └─ 制約 (例：時間枠、リソース)
        └─ 指標要素 (例：コスト、効率、バランス)
  ↓
(2) モデル設計（意図モデル化）
  ├─ 意図を複数の「シンプル指標 (線形式)」で表現
  ├─ 各指標に重みを持たせ、線形結合する形を想定
  └─ 切り替えルール (どの状況でどの重み／指標を優先するか)
  ↓
(3) 逆強化学習ベース学習ループ (意図学習)
  ├─ 初期化
  │     ├─ 最適化指標の重み (重み初期値)
  │     └─ 数理最適化ソルバを準備 (スケジューリングソルバ)
  ├─ --反復処理--:
  │     ├─ 与えられた重みで最適解を計算（最適化ソルバを実行）
  │     ├─ 得られた最適解と熟練者の履歴との差異を評価
  │     └─ 重みを更新 (差異を小さくするように最適化指標の重みを調整)
  └─ 収束判定 (差異が十分小さければ終了)
  ↓
(4) 学習効率化の工夫
  ├─ 熟練者の “非最適 (サンプル) 履歴” も活用
  ├─ 近似的な最適解を推定 → 常に完全最適化ソルバを回さない
  └─ ソルバ実行回数を削減し計算コストを下げる
  ↓
(5) 意図モデル完成
  └─ 各指標重み + 切り替えルールが定まった「学習済意図モデル」
  ↓
(6) スケジューリング生成 (模倣フェーズ)
  ├─ 意図モデルを使って最適化問題を解く (スケジューリング最適化)
  └─ AI によるスケジューリング案を生成
  ↓
(7) 評価・検証
  ├─ 生成スケジュール vs 熟練者スケジュール：類似度 (例：コサイン距離など)
  ├─ 実用性テスト (運用上、制約違反や実務適合性の検証)
  └─ 必要に応じてモデル／重みの微調整
  ↓
(8) 運用・展開
  ├─ 日常業務への適用 (例：広告スケジューリング、シフト割り当て)
  └─ 継続学習 (新たな履歴が積まれたらモデルを再学習)
  ↓
ゴール：--熟練者の意思決定を忠実に模倣したスケジューリングを AI によって自動生成--

### 詳細設計

#### ### 1. データ収集・前処理

- [x] 熟練者の意思決定履歴データを収集する
  - ツールでは，人による修正履歴をデータベースに保存する機構を設ける
- [ ] 履歴データが最適解か非最適解かの分類ルールを決める
- [x] データ粒度（1タスク単位 / 1日単位 / 1案件単位）を決める
  - 1案件単位（ガントチャート一つ，もしくは数理最適化ロジックが扱う粒度と合わせる）
- [x] スケジューリング問題の入出力形式（ジョブ、リソース、時間枠など）を定義
  - 入力はスケジュールyamlと環境コンフィグyaml
  - 出力も同形式
- [ ] 欠損データ・ノイズデータの処理方法を決める
  - pend
- [x] 履歴データから状態・行動・結果（Before/After）を抽出する方法を確立
  - 履歴データからは，スケジューリング問題の入出力が入手される想定なので，強化学習的な数stepのスケジューリングは想定しておらず，単一の問題と結果のペアが一つの履歴データになる想定

---

#### ### 2. 問題構造・制約条件のモデル化

- [ ] スケジューリング問題の制約一覧を整理
- [ ] 各制約を形式的に数式化（線形／非線形の区分）
- [ ] 制約違反の扱いを決める（禁止 or ペナルティ方式）
- [ ] 業務ルールに依存する特殊制約（例：優先顧客、休日規定）を整理
- [ ] 多目的最適化にするか、単一目的に集約するか方針を決める

---

#### ### 3. 意図（評価指標）の設計

- [ ] 意図となり得る“評価指標候補”の洗い出し
  - 例：作業時間、負荷均等、実行順序、視聴率ギャップ 等
- [ ] 各評価指標を線形式で表現するルールの設計
- [ ] モデルに含める指標数の決定（少なすぎると表現力不足、多すぎると冗長）
- [ ] どの状況でどの指標を優先するか（意図切り替えルール）のモデル化
- [ ] 切り替え条件の特徴量設計（時間帯・残作業量・資源負荷など）

---

#### ### 4. 逆強化学習（IRL）による重み学習設計

- [ ] 目的関数のパラメータ（重み）の初期値設定
- [ ] 最適化ソルバの種類を選定（MILP, CP-Solver, heuristic solver など）
- [ ] 熟練者解とモデル最適解の距離（類似度）指標を定義
- [ ] 重み更新アルゴリズム（勾配法、EM型、近似最適化など）を選定
- [ ] 学習反復の終了条件（精度 or 反復数）を明確化
- [ ] 計算量を見積り、必要リソース（メモリ・CPU）を決める

---

#### ### 5. 学習効率化の仕組み

- [ ] ソルバを毎回起動せず“近似最適解”を生成する仕組みを決める
- [ ] 熟練者の非最適データを利用する方法を設計
- [ ] 近似モデルの構造（単純回帰 / NN / 木モデル）を選ぶ
- [ ] どのタイミングで本物のソルバを呼ぶかの戦略を定義
- [ ] ソルバの計算時間制限 / 近似精度の基準を決める

---

#### ### 6. モデル評価設計

- [ ] 熟練者スケジュールとの類似度評価指標を決める（例：コサイン類似度）
- [ ] 制約違反率の評価指標を決める
- [ ] 現場業務視点での評価観点（運用性、説明可能性）を整理
- [ ] 意図切り替えが正しく学習されているかの検証手法を決める
- [ ] 実運用データでの A/B テスト計画を作成する

---

#### ### 7. 推論フェーズ（スケジュール自動生成）設計

- [ ] 学習済み重みでソルバを回す処理フローを設計
- [ ] 切り替えルールに応じた重みの動的切り替え設計
- [ ] 推論時に必要な入力データ（案件、制約、リソース状況）を定義
- [ ] スケジュール出力形式（表形式、ガントチャートなど）を決める
- [ ] 制約違反を許容しない設計か、修正ループありにするか決定

---

#### ### 8. 運用・継続学習設計

- [ ] 新しい履歴データでの再学習タイミングの設計
- [ ] 現場ユーザーが操作しやすい UI の検討
- [ ] モデルが生成した理由（重みと切替条件）を説明する仕組み
- [ ] 業務ルール変更時のモデル再学習プロセス
- [ ] 異常値（実務に使えないスケジュール）を検知する仕組み

---

#### ### 9. セキュリティ・品質・保守性

- [ ] 業務データの匿名化・アクセス管理
- [ ] モデルのバージョン管理方法を確立
- [ ] ソルバのログ管理
- [ ] 長期運用を見据えたテスト計画（回帰テスト）
- [ ] 業務担当者・熟練者への説明資料整備
